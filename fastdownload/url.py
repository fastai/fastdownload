# AUTOGENERATED! DO NOT EDIT! File to edit: 01_url.ipynb (unless otherwise specified).

__all__ = ['URLs', 'FastDownload']

# Cell
import json
import warnings
from nbdev.showdoc import *
from fastprogress.fastprogress import progress_bar
from fastcore.all import *
from .helper import *

# Cell
def _check_present(url_meta):
    # TODO: Is there a better way?
    return len(url_meta)==3

# Cell
def _get_dset_name(url):
    checks = json.load(open(Path(__file__).parent/'checks.txt', 'r'))
    for key, val in checks.items():
        if val[0]==url: return key
    else: raise ValueError(f"No dataset exists at {Path(__file__).parent/'checks.txt'} for url - {url}")

# Cell
def _add_check(fpath, url):
    "Internal function to update the internal check file with `url` and check on `fname`."
    checks = json.load(open(Path(__file__).parent/'checks.txt', 'r'))
    dset_name = _get_dset_name(url)
    checks[dset_name] = [url] + _check_file(fpath)
    json.dump(checks, open(Path(__file__).parent/'checks.txt', 'w'), indent=2)

# Cell
def _check_file(fpath):
    "internal function to get the hash of the local file at `fname`."
    size = os.path.getsize(fpath)
    with open(fpath, "rb") as f: hash_nb = hashlib.md5(f.read(2**20)).hexdigest()
    return [size,hash_nb]

# Cell
def _get_check(url):
    "internal function to get the hash of the file at `url`."
    checks = json.load(open(Path(__file__).parent/'checks.txt', 'r'))
    dset_name = _get_dset_name(url)
    return checks.get(dset_name)[1:]

# Cell
def _get_URLs():
    "internal function to get the URLs from `checks.txt`"
    URLs = json.load(open(Path(__file__).parent/'checks.txt', 'r'))
    return dict2obj(URLs)

# Cell
URLs = _get_URLs()

# Cell
class FastDownload:
    def __init__(self, cfg=None, dir='~/.fastai', archive_path=None, data_path=None, overwrite=False):
        config = Config() if cfg is None else cfg
        data_path = data_path or config['data']
        archive_path = archive_path or config['archive']
        store_attr('data_path, archive_path')

    def download(self, url_meta, dest=None):
        url = url_meta[0]
        fname = Path(url.split('/')[-1])
        fpath = self.archive_path/fname
        dest  = self.data_path/fname.with_suffix('')
        if not dest.exists():
            fpath = download_data(src=url, dest=fpath)
            if not _check_present(url_meta): _add_check(fpath, url)
            if _get_check(url) and _check_file(fpath) != _get_check(url):
                warnings.warn(f"File downloaded seems broken. Remove {fname} and try again.")
            file_extract(fpath, dest.parent)
        return dest